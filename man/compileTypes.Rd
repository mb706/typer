% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/typer.R
\name{compileTypes}
\alias{compileTypes}
\title{Convert Argument Annotations to Argument Checks}
\usage{
compileTypes(env = parent.frame(), ...)
}
\arguments{
\item{env}{The environment to parse. Defaults to \code{\link[=parent.frame]{parent.frame()}}.}

\item{...}{\code{include} or \code{exclude}, given as \code{character(1)} \code{\link[=grep]{grep()}} patterns.
These are applied in the order given, so it is possible to
first include certain functions, then exclude a subset of these,
and then include a subset of these excluded functions etc.\cr
This is usually not necessary to give, since \code{compileTypes} will
automatically ignore functions that do not have decorators, but helps
in cases where parameters have default values containing \code{:} or \code{|}
characters. This does \emph{not} switch of type checks for the function, and
in fact may produce errors if a function containing type decorators is
not converted.}
}
\value{
\code{NULL}
}
\description{
\code{compileTypes} uses function annotations of functions in the given
environment and adds them to the functions as type checks. This way, if
a function is called, it automatically checks the input value format. With
its default values, \code{compileTypes} works on all functions in the calling
environment. This way, if \code{compileTypes()} is called at the end of a package
(e.g. in a file named \code{zzz.R} in the \code{R} directory), it converts all
functions in that package.
}
\details{
A function annotation for a parameter has the form\preformatted{  parname = value : type | type | type
}

where \code{type} can be a class name or a vector of possible (atomic) values
indicated as \code{value(...)}. For special class names
\code{logical}, \code{character}, \code{numeric}, \code{list} the \code{\link{mode}}
is checked instead. The special class name \code{integer} checks
for integer values (that may still be given as \code{numeric}, i.e.
floating point, value). Suffixing any of these special class names with \code{.na}
allows missing values (\code{NA}s): \code{logical.na}, \code{character.na} etc.

The special class name \code{NULL} allows \code{NULL} values.

Non-list mode class names can be suffixed with \code{(n)},
where \code{n} is an integer indicating the required vector length.
Further possibilities are \code{(n, m)} to indicate length between
\code{n} and \code{m}. Leaving out \code{n} or \code{m} (\code{(, m)} or \code{(n, )}) only
sets a minimum or maximum length.

The \code{(n)} suffix also works for \code{value(...)}: \code{value(1, 2)(1)}
specifies that a value can be \code{1} or \code{2}. Note that \code{value(1, 2)}
also allows \code{c(1, 2)} and \code{c(1, 1, 2, 1)}.

Class names or value lists can be suffixed with \code{[]} to
indicate "list of", or \code{[n]} to indicate "length \code{n} list of".
Similarly to non list length indicators, a minimum and maximum
can also be given (\code{[n, m]}), any of which can be omitted.

Conditions for each type can be added in \code{[[} \code{]]} and separated
by \code{,}. Special conditions are \code{named}, \code{unique}, \code{uniquely.named},
which apply to lists (and, in case of nested lists, only apply to
the outermost list);
other conditions should be expressions that are evaluated in the
context of the given parameters as well as the function's environment
(and should probably involve the value at hand.

A special value of the \code{value} part is \code{.}(dot), which indicates that no
default value is given for the function: \code{param = . : numeric}.
}
\note{
The generated code calls functions from the \code{checkmate} package.
Therefore, a package using \code{compileTypes}, should have \code{checkmate} in the
\code{Imports} section of its \code{DESCRIPTION} file.
}
\examples{
# this function takes a parameter that is either a vector of two integer
# numbers (either datatype integer or numeric), a vector of three numbers,
# or a named list of data.frame that all have more than two rows.
fun = function(a = .:integer(2) | numeric(3) |
    data.frame[] [[named, all(sapply(a, nrow) > 2)]]) {
  NULL
}

compileTypes()
}
